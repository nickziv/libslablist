#!/bin/ksh

# The input size (we make it very large --- slab lists can handle it ;).

source ./common_vars


dtest[0]="../tests/insert.d"
dtest[1]="../tests/find_bubble_up.d"
dtest[2]="../tests/subseq.d"

# All tests execute asynchronously. Each job should, at peak, take up ~200M of
# RAM. Which means the tests need ~5G of RAM minimum to run. We can tolerate
# swapping, because we are not measuring performance. We are just checking
# correctness.
pfexec rm -r test_results 2> /dev/null
pfexec mkdir test_results
pfexec chmod go+rw test_results
rifile=test_results/insert_
rsfile=test_results/subseq_
rffile=test_results/find_
# XXX ON SLEEPS
#
# We add a sleep after every DTrace command, because not doing so results in
# all of the DTrace processes 'freezing'. Actually, they get permanently
# strand:d in the 'sleep' state (according to prstat output), and don't execute
# the given command at all. The sleeps are a workaround.
#
# The DTrace docs don't say anything about starting dtrace processes in rapid
# succession... They also don't say anything about executing 48 instances of
# it, simultaneously.
#
# Either way, for now, the two-second delay between exec's seems to do the
# trick. I don't know if this is a timing issue that results in a kind of
# dead-lock, if it is simply a matter of having too many dtrace processes, or
# both.
for i in {0..11}; do;

	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${cmd[$i]}"\
		-s ${dtest[0]} -o $rifile$i &;
	sleep 2;

	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${cmd[$i]}"\
		-s ${dtest[1]} -o $rffile$i &;
	sleep 2;

	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${scmd[$i]}"\
		-s ${dtest[0]} -o $rifile"s_"$i &;
	sleep 2;

	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${scmd[$i]}"\
		-s ${dtest[1]} -o $rffile"s_"$i &;
	sleep 2;
done;
#for i in {12..14}; do;
#	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${cmd[$i]}"\
#		-s ${dtest[2]} -o $rsfile$i &;
#	pfexec dtrace -L /opt/libslablist/include/dtrace/ -c "${scmd[$i]}"\
#		-s ${dtest[2]} -o $rsfile"s_"$i &;
#done;
echo Waiting...
wait;
